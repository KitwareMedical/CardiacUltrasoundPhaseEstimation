/*=========================================================================
 *
 *  Copyright Kitware Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/

#include <iostream>
#include <fstream>
#include <string>
#include <stdio.h>

// This header file <filename>CLP.h is auto-generated by cmake and contains
// the PARSE_ARGS macro that sets up command-line usage help and also parse
// command-line arguments
#include "DecodeRawPhysioCLP.h"

#define BIG_TO_LITTLE_ENDIAN_32(x) ((((x) & 0xFF000000) >> 24) | \
                                    (((x) & 0x00FF0000) >> 8) |  \
                                    (((x) & 0x0000FF00) << 8) |  \
                                    (((x) & 0x000000FF) << 24) ) 


// Define data structures
#pragma pack(1)  // This ensures your compiler does not pad the following structures

typedef struct
{
  unsigned int dwVersion;         // Version of this file header
  unsigned int dwNumFrames;       // Number of frames in this file
  unsigned int dwInfo;            // General info regarding this packet (bitfield)
  unsigned int dwReserved[7];

} VSI_RAW_FILE_HEADER;

typedef struct
{
  unsigned int dwTimeStamp;       // RAW hardware time stamp
  double       dbTimeStamp;       // Calculated time stamp in ms
  unsigned int dwFrameNumber;     // RAW frame number for this packet
  unsigned int dwInfo;            // General info regarding this packet (bitfield)
  unsigned int dwPacketSize;      // Size of packet excluding this header (data follows header)
  unsigned int dwReserved[8];
  
} VSI_RAW_FRAME_HEADER; 

#pragma pack()

using namespace std;

void mfread(void * ptr, size_t size, size_t count, FILE * stream)
{
  size_t res = fread(ptr, size, count, stream);
  if(res != count) {
    cerr << "fread error" << endl;
    exit(2);
  }
}

int main(int argc, char *argv[])
{
  // sets up help for command-line usage and parses command-line arguments
  PARSE_ARGS;

  FILE *infile = fopen(in_raw_file.c_str(), "rb");

  if(infile == NULL) {
    cerr << "Error reading input raw file" << endl;
    exit(1);
  }

  FILE *outfile = fopen(out_csv_file.c_str(), "w");

  // read file header
  VSI_RAW_FILE_HEADER hfile;

  mfread(&hfile, sizeof(hfile), 1, infile);

  cout << "Version = " << hfile.dwVersion << endl;
  cout << "Num Frames = " << hfile.dwNumFrames << endl;
  cout << "Frame type = " << (hfile.dwInfo & 0x00000006) << endl;

  // read frames
  double prevTimeStamp = 0, meanTimeStep = 0;

  for(unsigned int f = 0; f < hfile.dwNumFrames; f++) {

    cout << "Reading frame " << f << "/" << hfile.dwNumFrames << endl;

    // read frame headers
    VSI_RAW_FRAME_HEADER hframe;

    mfread(&hframe, sizeof(hframe), 1, infile);

    hframe.dwTimeStamp = BIG_TO_LITTLE_ENDIAN_32(hframe.dwTimeStamp);

    bool isFrameInvalid = (hframe.dwInfo & 0x00000001);

    cout << "\tTime stamp (hw) = " << hframe.dwTimeStamp << endl;
    cout << "\tTime stamp (ms) = " << hframe.dbTimeStamp << endl;
    cout << "\tFrame number = " << hframe.dwFrameNumber << endl;
    cout << "\tFrame data size = " << hframe.dwPacketSize << endl;
    cout << "\tFrame invalid = " << isFrameInvalid << endl;

    if(isFrameInvalid) {
      cerr << "Error - input file contains invalid frames" << endl;
      exit(1);
    }

    if(f > 0) {

      double curTimeStep = hframe.dbTimeStamp - prevTimeStamp;
      cout << "\tTime step (ms) = " << curTimeStep << endl;

      meanTimeStep += curTimeStep;

    }

    prevTimeStamp = hframe.dbTimeStamp;

    // read frame data
    int nSamples = hframe.dwPacketSize / 8;

    cout << "\tNum samples = " << nSamples << endl;

    short *ecg = new short[nSamples];
    short *respiration = new short[nSamples];
    short *temperature = new short[nSamples];
    short *bp = new short[nSamples];

    mfread(ecg, sizeof(short), nSamples, infile);
    mfread(respiration, sizeof(short), nSamples, infile);
    mfread(temperature, sizeof(short), nSamples, infile);
    mfread(bp, sizeof(short), nSamples, infile);

    for(unsigned int s = 0; s < nSamples; s++) {

      if(f == 0 && s == 0) {
        fprintf(outfile, 
                "Frame, Timestamp, Sample, ECG, Respiration, "
                "Temperature, Blood pressure");
      }

      fprintf(outfile, "\n%d, %f, %d, %d, %d, %d, %d", 
              hframe.dwFrameNumber, hframe.dbTimeStamp, s, 
              ecg[s], respiration[s], temperature[s], bp[s]); 
    }

    delete(ecg);
    delete(respiration);
    delete(temperature);
    delete(bp);
  }

  cout << "Mean time step = " << meanTimeStep << endl;
  cout << "Frames per sec = " << 1000.0 / meanTimeStep << endl;

  fclose(outfile);
  fclose(infile);

  return 0;
}
