/*=========================================================================
 *
 *  Copyright Kitware Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/

#include <fstream>
#include <iostream>
#include <map>
#include <stdio.h>
#include <stdlib.h>
#include <string>

using namespace std;

#include "itkDOMNodeXMLReader.h"
#include "itkImageFileWriter.h"

#include "itkIdentityTransform.h"
#include "itkNearestNeighborInterpolateImageFunction.h"
#include "itkLinearInterpolateImageFunction.h"
#include "itkBSplineInterpolateImageFunction.h"
#include "itkResampleImageFilter.h"

// This header file <filename>CLP.h is auto-generated by cmake and contains
// the PARSE_ARGS macro that sets up command-line usage help and also parse
// command-line arguments
#include "DecodeVevo2100FilesCLP.h"

// File header values
#define VSI_RF_FILE_HEADER_INFO_DATA_IQ   0x00000000
#define VSI_RF_FILE_HEADER_INFO_DATA_RAW  0x00000002
#define VSI_RF_FILE_HEADER_INFO_DATA_RF   0x00000004
#define VSI_RF_FILE_HEADER_INFO_DATA_RAW8 0x00000008

#define BIG_TO_LITTLE_ENDIAN_32(x) ((((x) & 0xFF000000) >> 24) | \
                                    (((x) & 0x00FF0000) >> 8) |  \
                                    (((x) & 0x0000FF00) << 8) |  \
                                    (((x) & 0x000000FF) << 24) ) 

// Define data structures
#pragma pack(1)  // This ensures your compiler does not pad the following structures

typedef struct
{
  unsigned int dwVersion;         // Version of this file header
  unsigned int dwNumFrames;       // Number of frames in this file
  unsigned int dwInfo;            // General info regarding this packet (bitfield)
  unsigned int dwReserved[7];

} VSI_RAW_FILE_HEADER;

typedef struct
{
  unsigned int dwTimeStamp;       // RAW hardware time stamp
  double       dbTimeStamp;       // Calculated time stamp in ms
  unsigned int dwFrameNumber;     // RAW frame number for this packet
  unsigned int dwInfo;            // General info regarding this packet (bitfield)
  unsigned int dwPacketSize;      // Size of packet excluding this header (data follows header)
  unsigned int dwReserved[8];
  
} VSI_RAW_FRAME_HEADER; 

#pragma pack()

typedef map<string, string> ParameterMapType;

#define present(c, k) (c.find(k) != c.end())

void mfread(void * ptr, size_t size, size_t count, FILE * stream)
{
  size_t res = fread(ptr, size, count, stream);
  if(res != count) {
    cerr << "fread error" << endl;
    exit(2);
  }
}


void read_parameter_file(string xml_parameter_file, ParameterMapType &pmap)
{
  // Read xml file and get root DOM object
  itk::DOMNodeXMLReader::Pointer pxmlReader = itk::DOMNodeXMLReader::New();
  pxmlReader->SetFileName(xml_parameter_file.c_str());
  pxmlReader->Update();

  itk::DOMNode::Pointer root = pxmlReader->GetOutput();

  // Iterate through all children
  for(unsigned int i = 0; i < root->GetNumberOfChildren(); i++) {

    itk::DOMNode::ConstPointer curChild = root->GetChild(i);

    string key = curChild->GetAttribute("name");
    string value = curChild->GetAttribute("value");
    pmap[key] = value;

    // cout << "\t" << key << " = " << value << endl;
  }

}


int main(int argc, char *argv[])
{
  // sets up help for command-line usage and parses command-line arguments
  PARSE_ARGS;

  /* *************************************************************************
   *
   *              Read parameters from .raw.xml parameter file
   *
   **************************************************************************/

  cout << "\nReading .raw.xml parameter file ... " << endl;

  ParameterMapType pmap;

  read_parameter_file(xml_parameter_file, pmap);

  if(pmap["Data-Format"].compare("RAW") != 0) {
    cerr << "ERROR: Only RAW data format is supported" << endl;
    exit(1);
  }

  int numLines = std::atoi(pmap["B-Mode/Lines"].c_str());
  int numSamplesPerLine = std::atoi(pmap["B-Mode/Samples"].c_str());
  int numFocalZones = std::atoi(pmap["B-Mode/Focal-Zones-Count"].c_str());
  
  double physDepthOffset = std::atof(pmap["B-Mode/Depth-Offset"].c_str());
  double physDepth = std::atof(pmap["B-Mode/Depth"].c_str());
  double physWidth = std::atof(pmap["B-Mode/Width"].c_str());
  double physHeight = physDepth - physDepthOffset;
  
  if(numFocalZones != 1) {
    cerr << "ERROR: B-Mode/Focal-Zones-Count in xml file must be 1" << endl;
    exit(3);
  }

  cout << "\tNum Lines = " << numLines << endl;
  cout << "\tNum Samples Per Line = " << numSamplesPerLine << endl;
  cout << "\tDepth offset (mm) = " << physDepthOffset << endl;
  cout << "\tDepth (mm) = " << physDepth << endl;
  cout << "\tWidth (mm) = " << physWidth << endl;
  cout << "\tHeight (mm) = " << physHeight << endl;

  /* *************************************************************************
   *
   *                         Decode .raw.bmode file
   *
   **************************************************************************/

  cout << "Decoding .raw.bmode file ..." << endl;

  // open raw.bmode file
  FILE *fbmode = fopen(in_raw_bmode_file.c_str(), "rb");

  if(fbmode == NULL) {
    cerr << "Error reading input raw file" << endl;
    exit(1);
  }

  // read file header
  VSI_RAW_FILE_HEADER hfile_bmode;

  mfread(&hfile_bmode, sizeof(hfile_bmode), 1, fbmode);

  bool is8BitRawData = ((hfile_bmode.dwInfo & 
                         VSI_RF_FILE_HEADER_INFO_DATA_RAW8) == 
                        VSI_RF_FILE_HEADER_INFO_DATA_RAW8);
  
  cout << "Version = " << hfile_bmode.dwVersion << endl;
  cout << "Num Frames = " << hfile_bmode.dwNumFrames << endl;
  printf("dwInfo = 0x%X\n", hfile_bmode.dwInfo);
  cout << "Frame type = " << (hfile_bmode.dwInfo & 0x00000006) << endl;
  cout << "Bit depth = " << (is8BitRawData ? 8 : 32) << endl;

  if(!is8BitRawData) {
    cerr << "ERROR: Only 8-bit RAW files are supported" << endl;
    exit(3);
  }


  // read bmode frames and create itk volume
  typedef itk::Image<unsigned char, 3> BModeVideoType;
  BModeVideoType::Pointer bmodeVideo = BModeVideoType::New();

  double prevBmodeTimeStamp, meanBmodeTimeStep = 0;

  vector<double> ts_bmode(hfile_bmode.dwNumFrames, 0);

  for(unsigned int f = 0; f < hfile_bmode.dwNumFrames; f++) {

    cout << "Reading frame " << (f+1) << "/" << hfile_bmode.dwNumFrames << endl;

    // read frame header
    VSI_RAW_FRAME_HEADER hframe;

    mfread(&hframe, sizeof(hframe), 1, fbmode);

    hframe.dwTimeStamp = BIG_TO_LITTLE_ENDIAN_32(hframe.dwTimeStamp);

    bool isFrameInvalid = (hframe.dwInfo & 0x00000001);

    cout << "\tTime stamp (hw) = " << hframe.dwTimeStamp << endl;
    cout << "\tTime stamp (ms) = " << hframe.dbTimeStamp << endl;
    cout << "\tFrame number = " << hframe.dwFrameNumber << endl;
    cout << "\tFrame data size = " << hframe.dwPacketSize << endl;
    cout << "\tFrame invalid = " << isFrameInvalid << endl;

    if(isFrameInvalid) {
      cerr << "Error - input file contains invalid frames" << endl;
      exit(1);
    }

    ts_bmode[f] = hframe.dbTimeStamp;

    if(f > 0) {

      double curBmodeTimeStep = hframe.dbTimeStamp - prevBmodeTimeStamp;
      cout << "\tTime step (ms) = " << curBmodeTimeStep << endl;
      
      meanBmodeTimeStep += curBmodeTimeStep;

    }

    prevBmodeTimeStamp = hframe.dbTimeStamp;

    // allocate space for image
    if(f == 0) {

      BModeVideoType::SizeType sz;
      sz[0] = numLines;
      sz[1] = numSamplesPerLine;
      sz[2] = hfile_bmode.dwNumFrames;
    
      BModeVideoType::RegionType rgn;
      rgn.SetSize(sz);
      
      bmodeVideo->SetRegions(rgn);
      bmodeVideo->Allocate();
      bmodeVideo->FillBuffer(0);      

    }

    // read frame data one m-mode line at a time
    for(unsigned int x = 0; x < numLines; x++) {
      
      // read m-mode line data
      for(unsigned int y = 0; y < numSamplesPerLine; y++) {

        // read pixel intensity value
        unsigned char curPixelVal;

        mfread(&curPixelVal, sizeof(curPixelVal), 1, fbmode);

        // store pixel value
        BModeVideoType::IndexType index;
        index[0] = x;
        index[1] = y;
        index[2] = f;
        bmodeVideo->SetPixel(index, curPixelVal);
      }

    }
  }

  meanBmodeTimeStep /= (hfile_bmode.dwNumFrames - 1);

  cout << "Mean time step = " << meanBmodeTimeStep << endl;
  cout << "Frames per sec = " << 1000.0 / meanBmodeTimeStep << endl;

  // set spacing
  BModeVideoType::SpacingType spacing;

  spacing[0] = physWidth / numLines;
  spacing[1] = (physDepth - physDepthOffset) / numSamplesPerLine;
  spacing[2] = meanBmodeTimeStep;

  bmodeVideo->SetSpacing(spacing);

  // set origin
  BModeVideoType::PointType origin;

  origin[0] = 0.5 * physWidth;
  origin[1] = -physDepthOffset;
  origin[2] = 0.0;

  // bmodeVideo->SetOrigin(origin);

  // resample image to correct dimensions
  BModeVideoType::SizeType inSize = 
    bmodeVideo->GetLargestPossibleRegion().GetSize();

  double wScale = physWidth / physHeight;

  BModeVideoType::SizeType outSize = inSize;
  outSize[0] = (int) (wScale * numSamplesPerLine + 0.5);
  
  BModeVideoType::SpacingType outSpacing = bmodeVideo->GetSpacing();
  outSpacing[0] *= (double) inSize[0] / outSize[0];

  typedef itk::LinearInterpolateImageFunction<
    BModeVideoType, double> InterpolatorType;

  typedef itk::IdentityTransform<double , 3> TransformType;

  typedef itk::ResampleImageFilter<
    BModeVideoType, BModeVideoType> ResampleFilterType;
  ResampleFilterType::Pointer resampleFilter = ResampleFilterType::New();

  resampleFilter->SetInput(bmodeVideo);
  resampleFilter->SetSize(outSize);
  resampleFilter->SetOutputSpacing(outSpacing);
  resampleFilter->SetTransform(TransformType::New());
  resampleFilter->SetInterpolator(InterpolatorType::New());
  resampleFilter->UpdateLargestPossibleRegion();

  bmodeVideo = resampleFilter->GetOutput();

  cout << "BMode video size = " 
       << bmodeVideo->GetLargestPossibleRegion().GetSize() << endl;
  cout << "BMode video spacing = " 
       << bmodeVideo->GetSpacing() << endl;

  // write image
  typedef itk::ImageFileWriter< BModeVideoType > ImageWriterType;

  ImageWriterType::Pointer imageWriter = ImageWriterType::New();
  imageWriter->SetFileName(out_bmode_file.c_str());
  imageWriter->SetInput(bmodeVideo);
  imageWriter->Update();

  // close bmode file
  fclose(fbmode);

  /* *************************************************************************
   *
   *                          Decode raw.physio file
   *
   **************************************************************************/
  
  cout << "Decoding .raw.physio file ..." << endl;

  // read raw physio file
  FILE *fphysio = fopen(in_raw_physio_file.c_str(), "rb");

  if(fphysio == NULL) {
    cerr << "Error reading input raw file" << endl;
    exit(1);
  }

  // read file header
  VSI_RAW_FILE_HEADER hfile_physio;

  mfread(&hfile_physio, sizeof(hfile_physio), 1, fphysio);

  cout << "Version = " << hfile_physio.dwVersion << endl;
  cout << "Num Frames = " << hfile_physio.dwNumFrames << endl;
  cout << "Frame type = " << (hfile_physio.dwInfo & 0x00000006) << endl;

  // read frames
  double prevPhysioTimeStamp, meanPhysioTimeStep = 0;

  vector<long> frame_id, sample_id, sample_count;
  vector<double> frame_ts, sample_ts;
  vector<short> ecg, respiration, temperature, bp;

  for(unsigned int f = 0; f < hfile_physio.dwNumFrames; f++) {

    cout << "Reading frame " << f << "/" << hfile_physio.dwNumFrames << endl;

    // read frame headers
    VSI_RAW_FRAME_HEADER hframe;

    mfread(&hframe, sizeof(hframe), 1, fphysio);

    hframe.dwTimeStamp = BIG_TO_LITTLE_ENDIAN_32(hframe.dwTimeStamp);

    bool isFrameInvalid = (hframe.dwInfo & 0x00000001);

    cout << "\tTime stamp (hw) = " << hframe.dwTimeStamp << endl;
    cout << "\tTime stamp (ms) = " << hframe.dbTimeStamp << endl;
    cout << "\tFrame number = " << hframe.dwFrameNumber << endl;
    cout << "\tFrame data size = " << hframe.dwPacketSize << endl;
    cout << "\tFrame invalid = " << isFrameInvalid << endl;

    if(isFrameInvalid) {
      cerr << "Error - input file contains invalid frames" << endl;
      exit(1);
    }

    if(f > 0) {

      double curTimeStep = hframe.dbTimeStamp - prevPhysioTimeStamp;
      cout << "\tTime step (ms) = " << curTimeStep << endl;

      meanPhysioTimeStep += curTimeStep;

    }

    prevPhysioTimeStamp = hframe.dbTimeStamp;

    // read frame data
    int nSamples = hframe.dwPacketSize / 8;

    cout << "\tNum samples = " << nSamples << endl;

    short *cur_ecg = new short[nSamples];
    short *cur_respiration = new short[nSamples];
    short *cur_temperature = new short[nSamples];
    short *cur_bp = new short[nSamples];

    mfread(cur_ecg, sizeof(short), nSamples, fphysio);
    mfread(cur_respiration, sizeof(short), nSamples, fphysio);
    mfread(cur_temperature, sizeof(short), nSamples, fphysio);
    mfread(cur_bp, sizeof(short), nSamples, fphysio);

    for(unsigned int s = 0; s < nSamples; s++) {

      frame_id.push_back(f);
      sample_id.push_back(s);
      sample_count.push_back(nSamples);

      frame_ts.push_back(hframe.dbTimeStamp);
      sample_ts.push_back(hframe.dbTimeStamp);

      ecg.push_back(cur_ecg[s]);
      respiration.push_back(cur_respiration[s]);
      temperature.push_back(cur_temperature[s]);
      bp.push_back(cur_bp[s]);
    }

    delete(cur_ecg);
    delete(cur_respiration);
    delete(cur_temperature);
    delete(cur_bp);
  }

  meanPhysioTimeStep /= (hfile_physio.dwNumFrames - 1);

  cout << "Mean time step = " << meanPhysioTimeStep << endl;
  cout << "Frames per sec = " << 1000.0 / meanPhysioTimeStep << endl;

  // close raw physio file
  fclose(fphysio);  

  // calculate time stamp of each sample
  for(int i = 0; i < frame_ts.size(); i++) {

    sample_ts[i] = (frame_ts[i] + 
                    sample_id[i] * meanPhysioTimeStep / sample_count[i]);

  }

  /* *************************************************************************
   *
   *                          Write output csv files
   *
   **************************************************************************/

  // write output physio csv file
  cout << "Writing physio csv file ..." << endl;

  FILE *fphysio_csv = fopen(out_physio_csv_file.c_str(), "w");

  for(int i = 0; i < frame_ts.size(); i++) {

    if(i == 0) {

        fprintf(fphysio_csv, 
                "Frame, Sample, Timestamp, ECG, Respiration, "
                "Temperature, Blood pressure");
    }

    fprintf(fphysio_csv, "\n%ld, %ld, %f, %d, %d, %d, %d", 
            frame_id[i], sample_id[i], sample_ts[i], 
            ecg[i], respiration[i], temperature[i], bp[i]); 

  }

  fclose(fphysio_csv);

  // write output bmode csv file
  cout << "Writing bmode csv file ..." << endl;

  FILE *fbmode_csv = fopen(out_bmode_csv_file.c_str(), "w");

  for(int f = 0; f < ts_bmode.size(); f++) {
    
    // find physio sample with closest timestamp
    double min_dist = abs(sample_ts[0] - ts_bmode[f]);
    double min_s = 0;
    
    for(int s = 1; s < sample_ts.size(); s++) {
      
      double cur_dist = abs(sample_ts[s] - ts_bmode[f]);

      if(cur_dist < min_dist) {
        min_dist = cur_dist;
        min_s = s;
      }
      
    }

    // write to file
    if(f == 0) {

        fprintf(fbmode_csv, 
                "Frame, Frame timestamp, Sample timestamp, ECG, Respiration, "
                "Temperature, Blood pressure");
    }

 
    fprintf(fbmode_csv, "\n%d, %f, %f, %d, %d, %d, %d", 
            f, ts_bmode[f], sample_ts[min_s],
            ecg[min_s], respiration[min_s], 
            temperature[min_s], bp[min_s]);     

    printf("\n%d, %f, %f, %d, %d, %d, %d", 
           f, ts_bmode[f], sample_ts[min_s],
           ecg[min_s], respiration[min_s], 
           temperature[min_s], bp[min_s]);     
  }

  fclose(fbmode_csv);

  return 0;
}
