/*=========================================================================
 *
 *  Copyright Kitware Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/

#include <fstream>
#include <iostream>
#include <map>
#include <stdio.h>
#include <stdlib.h>
#include <string>

using namespace std;

#include "itkDOMNodeXMLReader.h"
#include "itkImageFileWriter.h"

#include "itkIdentityTransform.h"
#include "itkNearestNeighborInterpolateImageFunction.h"
#include "itkResampleImageFilter.h"


// This header file <filename>CLP.h is auto-generated by cmake and contains
// the PARSE_ARGS macro that sets up command-line usage help and also parse
// command-line arguments
#include "DecodeRawBmodeCLP.h"

// File header values
#define VSI_RF_FILE_HEADER_INFO_DATA_IQ   0x00000000
#define VSI_RF_FILE_HEADER_INFO_DATA_RAW  0x00000002
#define VSI_RF_FILE_HEADER_INFO_DATA_RF   0x00000004
#define VSI_RF_FILE_HEADER_INFO_DATA_RAW8 0x00000008

#define BIG_TO_LITTLE_ENDIAN_32(x) ((((x) & 0xFF000000) >> 24) | \
                                    (((x) & 0x00FF0000) >> 8) |  \
                                    (((x) & 0x0000FF00) << 8) |  \
                                    (((x) & 0x000000FF) << 24) ) 

// Define data structures
#pragma pack(1)  // This ensures your compiler does not pad the following structures

typedef struct
{
  unsigned int dwVersion;         // Version of this file header
  unsigned int dwNumFrames;       // Number of frames in this file
  unsigned int dwInfo;            // General info regarding this packet (bitfield)
  unsigned int dwReserved[7];

} VSI_RAW_FILE_HEADER;

typedef struct
{
  unsigned int dwTimeStamp;       // RAW hardware time stamp
  double       dbTimeStamp;       // Calculated time stamp in ms
  unsigned int dwFrameNumber;     // RAW frame number for this packet
  unsigned int dwInfo;            // General info regarding this packet (bitfield)
  unsigned int dwPacketSize;      // Size of packet excluding this header (data follows header)
  unsigned int dwReserved[8];
  
} VSI_RAW_FRAME_HEADER; 

#pragma pack()

typedef map<string, string> ParameterMapType;

#define present(c, k) (c.find(k) != c.end())

void mfread(void * ptr, size_t size, size_t count, FILE * stream)
{
  size_t res = fread(ptr, size, count, stream);
  if(res != count) {
    cerr << "fread error" << endl;
    exit(2);
  }
}


void read_parameter_file(string xml_parameter_file, ParameterMapType &pmap)
{
  // Read xml file and get root DOM object
  itk::DOMNodeXMLReader::Pointer pxmlReader = itk::DOMNodeXMLReader::New();
  pxmlReader->SetFileName(xml_parameter_file.c_str());
  pxmlReader->Update();

  itk::DOMNode::Pointer root = pxmlReader->GetOutput();

  // Iterate through all children
  for(unsigned int i = 0; i < root->GetNumberOfChildren(); i++) {

    itk::DOMNode::ConstPointer curChild = root->GetChild(i);

    string key = curChild->GetAttribute("name");
    string value = curChild->GetAttribute("value");
    pmap[key] = value;

    // cout << "\t" << key << " = " << value << endl;
  }

}

int main(int argc, char *argv[])
{
  
  // sets up help for command-line usage and parses command-line arguments
  PARSE_ARGS;

  // open raw.bmode file
  FILE *infile = fopen(in_raw_bmode_file.c_str(), "rb");

  if(infile == NULL) {
    cerr << "Error reading input raw file" << endl;
    exit(1);
  }

  // read file header
  VSI_RAW_FILE_HEADER hfile;

  mfread(&hfile, sizeof(hfile), 1, infile);

  bool is8BitRawData = ((hfile.dwInfo & VSI_RF_FILE_HEADER_INFO_DATA_RAW8) == 
                        VSI_RF_FILE_HEADER_INFO_DATA_RAW8);
  
  cout << "Version = " << hfile.dwVersion << endl;
  cout << "Num Frames = " << hfile.dwNumFrames << endl;
  printf("dwInfo = 0x%X\n", hfile.dwInfo);
  cout << "Frame type = " << (hfile.dwInfo & 0x00000006) << endl;
  cout << "Bit depth = " << (is8BitRawData ? 8 : 32) << endl;

  if(!is8BitRawData) {
    cerr << "ERROR: Only 8-bit RAW files are supported" << endl;
    exit(3);
  }

  // read essential parameters from xml parameter file
  cout << "Reading parameter file" << endl;

  map<string, string> pmap;

  read_parameter_file(xml_parameter_file, pmap);
  
  int numLines = std::atoi(pmap["B-Mode/Lines"].c_str());
  int numSamplesPerLine = std::atoi(pmap["B-Mode/Samples"].c_str());
  int numFocalZones = std::atoi(pmap["B-Mode/Focal-Zones-Count"].c_str());
  
  double physDepthOffset = std::atof(pmap["B-Mode/Depth-Offset"].c_str());
  double physDepth = std::atof(pmap["B-Mode/Depth"].c_str());
  double physWidth = std::atof(pmap["B-Mode/Width"].c_str());
  double physHeight = physDepth - physDepthOffset;
  
  if(numFocalZones != 1) {
    cerr << "ERROR: B-Mode/Focal-Zones-Count in xml file must be 1" << endl;
    exit(3);
  }

  cout << "\tNum Lines = " << numLines << endl;
  cout << "\tNum Samples Per Line = " << numSamplesPerLine << endl;
  cout << "\tDepth offset (mm) = " << physDepthOffset << endl;
  cout << "\tDepth (mm) = " << physDepth << endl;
  cout << "\tWidth (mm) = " << physWidth << endl;
  cout << "\tHeight (mm) = " << physHeight << endl;

  // read frames and create itk video/volume
  typedef itk::Image<unsigned char, 3> BModeVideoType;
  BModeVideoType::Pointer bmodeVideo = BModeVideoType::New();

  double prevTimeStamp = 0, meanTimeStep = 0;

  for(unsigned int f = 0; f < hfile.dwNumFrames; f++) {

    cout << "Reading frame " << (f+1) << "/" << hfile.dwNumFrames << endl;

    // read frame header
    VSI_RAW_FRAME_HEADER hframe;

    mfread(&hframe, sizeof(hframe), 1, infile);

    hframe.dwTimeStamp = BIG_TO_LITTLE_ENDIAN_32(hframe.dwTimeStamp);

    bool isFrameInvalid = (hframe.dwInfo & 0x00000001);

    cout << "\tTime stamp (hw) = " << hframe.dwTimeStamp << endl;
    cout << "\tTime stamp (ms) = " << hframe.dbTimeStamp << endl;
    cout << "\tFrame number = " << hframe.dwFrameNumber << endl;
    cout << "\tFrame data size = " << hframe.dwPacketSize << endl;
    cout << "\tFrame invalid = " << isFrameInvalid << endl;

    if(isFrameInvalid) {
      cerr << "Error - input file contains invalid frames" << endl;
      exit(1);
    }

    if(f > 0) {

      double curTimeStep = hframe.dbTimeStamp - prevTimeStamp;
      cout << "\tTime step (ms) = " << curTimeStep << endl;
      
      meanTimeStep += curTimeStep;

    }

    prevTimeStamp = hframe.dbTimeStamp;

    // allocate space for image
    if(f == 0) {

      BModeVideoType::SizeType sz;
      sz[0] = numLines;
      sz[1] = numSamplesPerLine;
      sz[2] = hfile.dwNumFrames;
    
      BModeVideoType::RegionType rgn;
      rgn.SetSize(sz);
      
      bmodeVideo->SetRegions(rgn);
      bmodeVideo->Allocate();
      bmodeVideo->FillBuffer(0);      

    }

    // read frame data one m-mode line at a time
    for(unsigned int x = 0; x < numLines; x++) {
      
      // read m-mode line data
      for(unsigned int y = 0; y < numSamplesPerLine; y++) {

        // read pixel intensity value
        unsigned char curPixelVal;

        mfread(&curPixelVal, sizeof(curPixelVal), 1, infile);

        // store pixel value
        BModeVideoType::IndexType index;
        index[0] = x;
        index[1] = y;
        index[2] = f;
        bmodeVideo->SetPixel(index, curPixelVal);
      }

    }
  }

  meanTimeStep /= (hfile.dwNumFrames - 1);

  cout << "Mean time step = " << meanTimeStep << endl;
  cout << "Frames per sec = " << 1000.0 / meanTimeStep << endl;

  // set spacing
  BModeVideoType::SpacingType spacing;

  spacing[0] = physWidth / numLines;
  spacing[1] = (physDepth - physDepthOffset) / numSamplesPerLine;
  spacing[2] = meanTimeStep;

  bmodeVideo->SetSpacing(spacing);

  // set origin
  BModeVideoType::PointType origin;

  origin[0] = 0.5 * physWidth;
  origin[1] = -physDepthOffset;
  origin[2] = 0.0;

  bmodeVideo->SetOrigin(origin);

  cout << "BMode video size = " 
       << bmodeVideo->GetLargestPossibleRegion().GetSize() << endl;
  cout << "BMode video spacing = " 
       << bmodeVideo->GetSpacing() << endl;

  // write image
  typedef itk::ImageFileWriter< BModeVideoType > ImageWriterType;

  ImageWriterType::Pointer imageWriter = ImageWriterType::New();
  imageWriter->SetFileName(out_bmode_file.c_str());
  imageWriter->SetInput(bmodeVideo);
  imageWriter->Update();

  // close files
  fclose(infile);

  return 0;
}
