/*=========================================================================
 *
 *  Copyright Kitware Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/

#include <fstream>
#include <iostream>
#include <map>
#include <stdio.h>
#include <stdlib.h>
#include <string>

using namespace std;

#include "itkDOMNodeXMLReader.h"
#include "itkImageFileWriter.h"

// This header file <filename>CLP.h is auto-generated by cmake and contains
// the PARSE_ARGS macro that sets up command-line usage help and also parse
// command-line arguments
#include "DecodeRawBmodeCLP.h"

typedef struct
{
  unsigned int dwVersion;
  unsigned int dwNumFrames;
  unsigned int dwInfo;
  unsigned int dwReserved[7];

} VSI_RAW_FILE_HEADER;

typedef struct
{
  unsigned int dwTimeStamp;
  double       dbTimeStamp;
  unsigned int dwFrameNumber;
  unsigned int dwInfo;
  unsigned int dwPacketSize;
  unsigned int dwReserved[8];
  
} VSI_RAW_FRAME_HEADER; 

#define BIG_TO_LITTLE_ENDIAN_32(x) ((((x) & 0xFF000000) >> 24) | \
                                    (((x) & 0x00FF0000) >> 8) |  \
                                    (((x) & 0x0000FF00) << 8) |  \
                                    (((x) & 0x000000FF) << 24) ) 

typedef map<string, string> ParameterMapType;

#define present(c, k) (c.find(k) != c.end())

void mfread(void * ptr, size_t size, size_t count, FILE * stream)
{
  size_t res = fread(ptr, size, count, stream);
  if(res != count) {
    cerr << "fread error" << endl;
    exit(2);
  }
}


void read_parameter_file(string xml_parameter_file, ParameterMapType &pmap)
{
  // Read xml file and get root DOM object
  itk::DOMNodeXMLReader::Pointer pxmlReader = itk::DOMNodeXMLReader::New();
  pxmlReader->SetFileName(xml_parameter_file.c_str());
  pxmlReader->Update();

  itk::DOMNode::Pointer root = pxmlReader->GetOutput();

  // Iterate through all children
  for(unsigned int i = 0; i < root->GetNumberOfChildren(); i++) {

    itk::DOMNode::ConstPointer curChild = root->GetChild(i);

    string key = curChild->GetAttribute("name");
    string value = curChild->GetAttribute("value");
    pmap[key] = value;

    // cout << "\t" << key << " = " << value << endl;
  }

}


int main(int argc, char *argv[])
{
  
  // sets up help for command-line usage and parses command-line arguments
  PARSE_ARGS;

  // open raw.bmode file
  FILE *infile = fopen(in_raw_bmode_file.c_str(), "rb");

  if(infile == NULL) {
    cerr << "Error reading input raw file" << endl;
    exit(1);
  }

  // read file header
  VSI_RAW_FILE_HEADER hfile;

  mfread(&hfile.dwVersion, sizeof(hfile.dwVersion), 1, infile);
  mfread(&hfile.dwNumFrames, sizeof(hfile.dwNumFrames), 1, infile);
  mfread(&hfile.dwInfo, sizeof(hfile.dwInfo), 1, infile);
  mfread(&hfile.dwReserved, sizeof(hfile.dwReserved), 1, infile);

  cout << "Version = " << hfile.dwVersion << endl;
  cout << "Num Frames = " << hfile.dwNumFrames << endl;
  cout << "Frame type = " << (hfile.dwInfo & 0x00000006) << endl;

  // read essential parameters from xml parameter file
  cout << "Reading parameter file" << endl;

  map<string, string> pmap;

  read_parameter_file(xml_parameter_file, pmap);
  
  int numLines = std::atoi(pmap["B-Mode/Lines"].c_str());
  int numSamplesPerLine = std::atoi(pmap["B-Mode/Samples"].c_str());
  int numFocalZones = std::atoi(pmap["B-Mode/Focal-Zones-Count"].c_str());
  
  double physDepthOffset = std::atof(pmap["B-Mode/Depth-Offset"].c_str());
  double physDepth = std::atof(pmap["B-Mode/Depth"].c_str());
  double physWidth = std::atof(pmap["B-Mode/Width"].c_str());
  
  double dbDynRange = std::atof(pmap["B-Mode/Display-Range"].c_str());
  double dbYOffset = std::atof(pmap["B-Mode/Y-Offset"].c_str());
  double dbVOffset = std::atof(pmap["B-Mode/V-Offset"].c_str());

  if(numFocalZones != 1) {
    cerr << "ERROR: B-Mode/Focal-Zones-Count in xml file must be 1" << endl;
    exit(3);
  }

  cout << "\tNum Lines = " << numLines << endl;
  cout << "\tNum Samples Per Line = " << numSamplesPerLine << endl;
  cout << "\tDepth offset (mm) = " << physDepthOffset << endl;
  cout << "\tDepth (mm) = " << physDepth << endl;
  cout << "\tWidth (mm) = " << physWidth << endl;
  cout << "\tDisplay Range = " << dbDynRange << endl;
  cout << "\tYOffset = " << dbYOffset << endl;
  cout << "\tVOffset = " << dbVOffset << endl;

  // read frames and create itk video/volume
  typedef itk::Image<float, 3> BModeVideoType;
  BModeVideoType::Pointer bmodeVideo = BModeVideoType::New();

  double prevTimeStamp = 0, meanTimeStep = 0;

  for(unsigned int f = 0; f < hfile.dwNumFrames; f++) {

    cout << "Reading frame " << (f+1) << "/" << hfile.dwNumFrames << endl;

    // read frame headers
    VSI_RAW_FRAME_HEADER hframe;

    mfread(&hframe.dwTimeStamp, sizeof(hframe.dwTimeStamp), 1, infile);
    mfread(&hframe.dbTimeStamp, sizeof(hframe.dbTimeStamp), 1, infile);
    mfread(&hframe.dwFrameNumber, sizeof(hframe.dwFrameNumber), 1, infile);
    mfread(&hframe.dwInfo, sizeof(hframe.dwInfo), 1, infile);
    mfread(&hframe.dwPacketSize, sizeof(hframe.dwPacketSize), 1, infile);
    mfread(&hframe.dwReserved, sizeof(hframe.dwReserved), 1, infile);

    hframe.dwTimeStamp = BIG_TO_LITTLE_ENDIAN_32(hframe.dwTimeStamp);

    bool isFrameInvalid = (hframe.dwInfo & 0x00000001);

    cout << "\tTime stamp (ms) = " << hframe.dbTimeStamp << endl;
    cout << "\tFrame number = " << hframe.dwFrameNumber << endl;
    cout << "\tFrame data size = " << hframe.dwPacketSize << endl;
    cout << "\tFrame invalid = " << isFrameInvalid << endl;

    if(f > 0) {

      double curTimeStep = hframe.dbTimeStamp - prevTimeStamp;
      cout << "\tTime step (ms) = " << curTimeStep << endl;
      
      meanTimeStep += curTimeStep;

    }

    prevTimeStamp = hframe.dbTimeStamp;

    // allocate space for image
    if(f == 0) {

      BModeVideoType::SizeType sz;
      sz[0] = numLines;
      sz[1] = numSamplesPerLine;
      sz[2] = hfile.dwNumFrames;
    
      BModeVideoType::RegionType rgn;
      rgn.SetSize(sz);
      
      bmodeVideo->SetRegions(rgn);
      bmodeVideo->Allocate();
      bmodeVideo->FillBuffer(0);      
    }

    // read frame data one m-mode line at a time
    for(unsigned int x = 0; x < numLines; x++) {
      
      // read m-mode line time stamp
      unsigned int curLineTimeStamp;

      mfread(&curLineTimeStamp, sizeof(unsigned int), 1, infile);
      curLineTimeStamp = BIG_TO_LITTLE_ENDIAN_32(curLineTimeStamp);

      // read m-mode line data
      for(unsigned int y = 0; y < numSamplesPerLine; y++) {

        // read pixel intensity value
        float rawVal;
        mfread(&rawVal, sizeof(float), 1, infile);

        // transform for display
        float curPixelVal = 255.0 / dbDynRange * (rawVal - dbYOffset) + dbVOffset;

        // store pixel value
        BModeVideoType::IndexType index;
        index[0] = x;
        index[1] = y;
        index[2] = f;
        bmodeVideo->SetPixel(index, curPixelVal);
      }

    }
  }

  meanTimeStep /= (hfile.dwNumFrames - 1);

  cout << "Mean time step = " << meanTimeStep << endl;
  cout << "Frames per sec = " << 1000.0 / meanTimeStep << endl;

  // set spacing
  BModeVideoType::SpacingType spacing;

  spacing[0] = physWidth / numLines;
  spacing[1] = (physDepth - physDepthOffset) / numSamplesPerLine;
  spacing[2] = meanTimeStep;

  bmodeVideo->SetSpacing(spacing);

  // set origin
  BModeVideoType::PointType origin;

  origin[0] = 0.5 * physWidth;
  origin[1] = -physDepthOffset;
  origin[2] = 0.0;

  bmodeVideo->SetOrigin(origin);

  // write image
  typedef itk::ImageFileWriter< BModeVideoType > ImageWriterType;

  ImageWriterType::Pointer imageWriter = ImageWriterType::New();
  imageWriter->SetFileName(out_bmode_file.c_str());
  imageWriter->SetInput(bmodeVideo);
  imageWriter->Update();

  // close files
  fclose(infile);

  return 0;
}
